# Decoratorパターン
## 用途・パターン
前回のコンポジットパターンとよく似ている。
元のオブジェクトに追加の処理をしていくのがデコレーター
この時デコレーターで包まれたものも元のオブジェクトと同じように扱うことができる。
ここがコンポジットと似ていて、デコレーターされたものをさらにデコレートすることができる。
これまでの機能追加系のパターンは「交換」していたけどデコレーターは追加の機能を重ねていくことができる。
追加の処理の順番が影響する処理にも合う。

## サンプル エフェクターシステム
エレキギターの原音に対してエフェクトをかけていく、エフェクターの部分をデコレーターにしたプログラムです
処理を重ねていく・交換したり順番を変える必要があるというのが、ギターのエフェクターの仕組みが合っていると思いました。
何も処理していないクリーンな音がコンクリートコンポーネント役
それにエフェクトをかけていくのがコンクリートデコレーター役

## クラス図

<img width="1113" alt="image" src="https://github.com/user-attachments/assets/08b13d17-6630-427c-be2b-132c0c618d1c" />

https://drive.google.com/file/d/1ehmFnMD3KmaPcUrvkTXtUSQmYeba3gdU/view?usp=sharing



# 宿題
- adapterとの違い 

- 継承 
委譲-_soundの部分が委譲 コンクリートデコレーターで_soundを委譲している
- 委譲について説明できるように
    - adapterは機能を追加しない
- P181? java.io パッケージとデコレーターパターンC# で考える
- (オンオフ-とかパラメーター調整　できればやってみる)


# 宿題'
## adapterパターンとの違い・継承移譲について
書籍を見るとアダプターパターンでは委譲と継承、両方のサンプルが紹介されていた。
委譲と継承はabstractやinterface、とは関係なくクラス間の関係
→本ではabstractで書いてるけど、パターンをネットで調べるとinterfaceを使っている例が多いとかがあって混乱していた。
abstractでもinterfaceでも機能、クラスの関係性としてパターンに合致していればどちらでもいいことがわかった。

- 継承
 - 元のクラスの機能を引き継ぐ。
 - 機能を使えるし発展させられる
- 委譲
  - （委譲する側）が（委譲される側）のインスタンスを中に持っている
  - だから継承とは違うけど、（委譲する側）がそのインスタンスを扱うなら「機能の継承」と近い
  - 委譲のパターンは所有してるインスタンスをちゃんとコントロールできていないと完全な委譲ではないんじゃないか？
  - 一部の委譲もある
  自分自身とその先でなんとかする→継承
  やりたいことをぶん投げてる→委譲

  


### adapterとDecoratorとの違い
- どっちも使いたいものをラップする（委譲adapterの場合）
- adapterは包むと別のものになる
  - 扱いたい形に変えてもらうのがadapter
- Decoratorは包んでも同じもの
  - だからまた同じように扱える

## java.ioのような例 C#
    Stream stream = new FileStream("file.txt", FileMode.Open);

    Stream bufferedStream = new BufferedStream(new FileStream("file.txt", FileMode.Open));
    Stream memoryStream = new MemoryStream(new byte[] { 0x41, 0x42, 0x43 });